<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Instruction analysis framework: Instruction analysis framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Instruction analysis framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Instruction analysis framework </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Description [En]</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Problem</h2>
<p>During the migration software to processors of the new open RISC-V architecture, the issue of optimizing programs for this architecture is acute. It would be useful for compiler developers or specialists optimizing specific sections of machine code in a non-trivial way manually to understand which applications and utilities in popular GNU/Linux distributions on the x86-64 platform use, for example, vector extensions or instructions to speed up encryption. This knowledge would help to understand how to improve the compiler or in which programs there are sections of machine code that need to be optimized manually for the RISC-V architecture.</p>
<p>This is far from the only case when statistical analysis of data on the appearance of various instructions (or groups of instructions) in the machine code of programs would be useful. Another example is the situation when the compiler developer needs to find out how the generated machine code of programs has changed in general after changes in the compiler. This technique, in particular, is used to assess the quality of firmware optimization of embedded systems such as routers and data warehouses.</p>
<p>In order to quickly find answers to such questions, a framework is being created that automates the collection of data on the use of machine instructions and provides tools for their statistical analysis and visualization.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Getting started</h2>
<p>To start using the capabilities of the framework, you need to</p><ol type="1">
<li>Make a fork of this repository.</li>
<li>Clone the fork.</li>
<li>Create and activate virtual environment. <div class="fragment"><div class="line">[InstructionAnalysisFramework]$ python -m venv venv</div>
<div class="line">[InstructionAnalysisFramework]$ source venv/bin/activate</div>
</div><!-- fragment --></li>
<li>Install requirements. <div class="fragment"><div class="line">(venv) [InstructionAnalysisFramework]$ pip install -r requirements.txt</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md4"></a>
Data collection</h2>
<p>A <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/data_collection/data_collection.py">Python script</a> was written to collect the data. It provides many options for configuration for the needs of particular users. In general, the script runs through certain files in parallel and tries to get an assembly listing of each file. If the attempt is successful, that is, the file contains the code, the path to the file and the number of all instructions found in it are recorded in a csv table, which is the result of the script. Program parameters determine which files script goes through. You can get acquainted with them as follows: </p><div class="fragment"><div class="line">(venv) [...]$ python data_collection/data_collection.py --help</div>
</div><!-- fragment --><p> For example, one can run a script on all files that are available in the system as follows: </p><div class="fragment"><div class="line">(venv) [...]$ python data_collection/data_collection.py -r &lt;path to the table&gt;</div>
</div><!-- fragment --><p> In order for data collection to take place on different GNU/Linux distributions, regardless of which operating system is installed on the machine on which the script is running, the script is run in Docker containers. The <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/tree/master/dockerfiles">dockerfiles</a> folder contains dockerfiles for building images. They include the installation of a utility for obtaining assembly listings of programs, as well as the installation of all programs whose machine code data the user wants to get. This approach allows the framework to achieve extensibility — to add a distribution for scanning, one just needs to add the corresponding docker file.</p>
<p>Data is collected using GitHub Actions in two stages (<a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/.github/workflows/DC.yml">yml-file</a>). First, the images are collected according to docker files and published in the <a href="https://hub.docker.com/repository/docker/danilapechenev/instruction-analysis/general">repository</a> on DockerHub. If the dockerfile has not been modified since the last GitHub Actions workflow, the image is not reassembled. At the next stage, data is collected on all distributions in parallel: in each distribution, an image is loaded from DockerHub, a Docker container is launched, and a Python script is run in it that generates a table with data. The resulting tables are stored in archives on GitHub Actions as workflow artifacts.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Data analysis</h2>
<p>Archives with tables are downloaded and analyzed in the Jupiter Notebook interactive environment both using standard functions provided by the pandas library and using <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/data_analysis/analysis_tool.py">functions</a> provided by the framework. An example of such an analysis with a demonstration of some capabilities of the tool is presented in <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/data_analysis/demo.ipynb">demo.ipynb</a>. The functions for analysis and visualization are carefully documented. The documentation is <a href="https://danila-pechenev.github.io/InstructionAnalysisFramework/namespaceanalysis__tool.html">published</a> on GitHub Pages and is updated automatically when changes occur.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Dvision of instructions into categories and groups</h2>
<p>There are a lot of instructions. This creates inconveniences when analyzing data about their use. It is necessary to divide the instructions into clusters. To solve this problem, a <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/scripts/x86-64_instructions.py">Python script</a> was written that collects information from <a href="https://linasm.sourceforge.net/docs/instructions/index.php">the site</a>, where a fairly large number of different instructions are presented. We call the category of the instruction the section of the site on the left where it is included, and the group — its subsection in it. Thus, the script collects for each instruction its description, category and group and stores the result in <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/x86-64_instructions.json">json file</a>. The division of instructions into categories and groups significantly increases completeness of information and clarity of data analysis.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Описание [Ru]</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
Проблема</h2>
<p>При миграции программного обеспечения на процессоры новой открытой архитектуры RISC-V остро стоит вопрос оптимизации программ именно под эту архитектуру. Разработчикам компиляторов или специалистам, оптимизирующим отдельные участки машинного кода нетривиальным образом вручную, было бы полезно понимать, в каких приложениях и утилитах в популярных дистрибутивах GNU/Linux на платформе x86-64 используются, например, векторные расширения или инструкции для ускорения шифрования. Эти знания помогли бы понять, как можно улучшить компилятор или в каких программах есть участки машинного кода, которые необходимо оптимизировать вручную для архитектуры RISC-V.</p>
<p>Это далеко не единственный случай, когда был бы полезен статистический анализ данных о появлении различных инструкций (или групп инструкций) в машинном коде программ. Другим примером является ситуация, когда разработчику компилятора необходимо узнать, как в целом поменялся сгенерированный машинный код программ после изменений в компиляторе. Эта методика, в частности, применяется для оценки качества оптимизации прошивок встраиваемых систем, например, маршрутизаторов и хранилищ данных.</p>
<p>С целью быстрого нахождения ответов на такого рода вопросы создается фреймворк, автоматизирующий сбор данных об использовании машинных инструкций и предоставляющий инструментарий для их статистического анализа и визуализации.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Начало работы</h2>
<p>Чтобы начать пользоваться возможностями фреймворка, необходимо</p><ol type="1">
<li>Сделать форк этого репозитория.</li>
<li>Склонировать форк.</li>
<li>Создать и активировать виртуальное окружение. <div class="fragment"><div class="line">[InstructionAnalysisFramework]$ python -m venv venv</div>
<div class="line">[InstructionAnalysisFramework]$ source venv/bin/activate</div>
</div><!-- fragment --></li>
<li>Установить необходимые пакеты. <div class="fragment"><div class="line">(venv) [InstructionAnalysisFramework]$ pip install -r requirements.txt</div>
</div><!-- fragment --> </li>
</ol>
<h2><a class="anchor" id="autotoc_md10"></a>
Сбор данных</h2>
<p>Для сбора данных был написан <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/data_collection/data_collection.py">Python-скрипт</a>. Он предоставляет множество возможностей для конфигурации под нужды конкретных пользователей. В целом, скрипт параллельно проходит по определенным файлам и пробует получить ассемблерный листинг каждого файла. Если попытка удачна, то есть файл содержит код, путь до файла и количество всех инструкций, встречающихся в нем, записываются в csv-таблицу, которая и является результатом работы скрипта. По каким именно файлам необходимо пройтись и определяют параметры программы. Ознакомиться с ними можно так: </p><div class="fragment"><div class="line">(venv) [...]$ python data_collection/data_collection.py --help</div>
</div><!-- fragment --><p> Например, запустить скрипт на всех файлах, которые имеются в системе, можно следующим образом: </p><div class="fragment"><div class="line">(venv) [...]$ python data_collection/data_collection.py -r &lt;path to the table&gt;</div>
</div><!-- fragment --><p> Чтобы сбор данных мог происходить на разных дистрибутивах GNU/Linux вне зависимости от того, какая операционная система установлена на машине, производящей запуск, скрипт запускается в Docker-контейнерах. В папке <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/tree/master/dockerfiles">dockerfiles</a> находятся докерфайлы для сборки образов. Они включают в себя установку утилиты для получения ассемблерных листингов программ, а также установку всех программ, данные о машинном коде которых пользователь хочет получить. Такой подход позволяет достигнуть расширяемости — чтобы добавить дистрибутив для сканирования, нужно лишь добавить соответствующий ему докерфайл.</p>
<p>Сбор данных происходит при помощи GitHub Actions в два этапа (<a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/.github/workflows/DC.yml">yml-файл</a>). Сначала образы собираются согласно докерфайлам и публикуются в <a href="https://hub.docker.com/repository/docker/danilapechenev/instruction-analysis/general">репозитории</a> на DockerHub. В случае, если докерфайл не был изменен с момента последнего запуска процесса на GitHub Actions, повторная сборка образа не производится. На следующем этапе данные собираются на всех дистрибутивах параллельно: в каждом дистрибутиве загружается образ с DockerHub, запускается Docker-контейнер, а в нем запускается Python-скрипт, генерирующий таблицу с данными. Полученные таблицы сохраняются в архивах как артефакты запуска процесса на GitHub Actions.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Анализ данных</h2>
<p>Архивы с таблицами скачиваются и анализируются в интерактивной среде Jupyter Notebook как при помощи стандартных функций, предоставляемых библиотекой pandas, так и с помощью <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/data_analysis/analysis_tool.py">функций</a>, предоставляемых фреймворком. Пример такого анализа с демонстрацией некоторых возможностей инструмента представлен в <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/data_analysis/demo.ipynb">demo.ipynb</a>. Функции для анализа и визуализации тщательно документирована. Документация <a href="https://danila-pechenev.github.io/InstructionAnalysisFramework/namespaceanalysis__tool.html">публикуется</a> на GitHub Pages и при изменениях обновляется автоматически.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Разделение инструкций на категории и группы</h2>
<p>Инструкций очень много. Это создает неудобства при анализе данных об их использовании. Необходимо разделить инструкции на кластеры. Для решения этой проблемы был написан <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/scripts/x86-64_instructions.py">Python-скрипт</a>, собирающий информацию с <a href="https://linasm.sourceforge.net/docs/instructions/index.php">сайта</a>, где представлено достаточно большое количество различных инструкций. Мы будем называть категорией инструкции тот раздел сайта слева, куда она включена, а группой — ее подраздел в нем. Таким образом, скрипт собирает для каждой инструкции ее описание, категорию и группу и сохраняет результат в <a href="https://github.com/Danila-Pechenev/InstructionAnalysisFramework/blob/master/x86-64_instructions.json">json-файле</a>. Разделение инструкций на категории и группы значительно повышает информативность и ясность анализа данных. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
